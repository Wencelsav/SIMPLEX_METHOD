#include<iostream>
#include<istream>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>

using namespace std;

// Условие задачи
vector<vector<double>> matrix_a = { { 2,1,2 },{ 1,2,0 },{ 0,0.5,1 } };
vector<double> matrix_b = { 6,6,2 };
vector<double> matrix_c = { 2,5,3 };


// Метод для вывода симплекс-таблицы
void print(double ** &simplex) {
	cout << setw(11) << " " << "      ";
	cout << setw(10) << "C"  << "      ";
	for(unsigned int i = 2; i <= matrix_c.size() + 1; ++i) {
		cout << setw(9) << "x" << simplex[0][i] << "      ";
	}
	cout << endl;
	for (unsigned int j = 1; j <= matrix_c.size() + 1; ++j) {
		if (j == matrix_c.size() + 1) cout << setw(11) << "F"  << "      ";
		else cout << setw(10) << "x" << simplex[j][0] << "      ";
		for (unsigned int i = 1; i <= matrix_c.size() + 1; ++i) {
			cout << setw(10) << simplex[j][i] << "      ";
		}
		cout << endl;
	}
	cout << endl;
}

// Метод, реализующий жордановы исключения
void JordanExeptions(double ** &simplex, unsigned int r, unsigned int k) {
	//changing all exept r and k
	for (unsigned int i = 1; i <= matrix_c.size() + 1; ++i) {
		if (i != r) {
			for (unsigned int j = 1; j <= matrix_b.size() + 1; ++j) {
				if (j != k) {
					simplex[i][j] = simplex[i][j] - (simplex[i][k] * simplex[r][j]) / simplex[r][k];
				}
			}
		}
	}
	//changing r and k
	for (unsigned int j = 1; j <= matrix_b.size() + 1; ++j) {
		if (j != k) {
			simplex[r][j] = simplex[r][j] / simplex[r][k];
		}
	}
	for (unsigned int i = 1; i <= matrix_b.size() + 1; ++i) {
		if (i != r) {
			simplex[i][k] = -simplex[i][k] / simplex[r][k];
		}
	}
	//changing rk
	simplex[r][k] = 1 / simplex[r][k];
	//change vars
	swap(simplex[0][k], simplex[r][0]);;
}

// Метод создания симплекс-таблицы из исходных данных
void create_simplex(double ** &simplex_matrix) {
	//filling with 0s
	for (unsigned int i = 0; i <= matrix_c.size() + 1; ++i) {
		for (unsigned int j = 0; j <= matrix_b.size() + 1; ++j) {
			simplex_matrix[j][i] = 0;
		}
	}
	//filing hat
	for (unsigned int i = 1; i <= matrix_a[0].size() + 1; ++i) {
		simplex_matrix[0][i] = i - 1;
	}
	for (unsigned int j = 1; j <= matrix_b.size(); ++j) {
		simplex_matrix[j][0] = matrix_c.size() + j;
	}
	//filling B
	for (unsigned int i = 0; i < matrix_b.size(); ++i) {
		simplex_matrix[i + 1][1] = matrix_b[i];
	}
	//filling C
	for (unsigned int i = 1; i <= matrix_c.size(); ++i) {
		simplex_matrix[matrix_b.size() + 1][i + 1] = matrix_c[i - 1];
	}
	//Filling A
	for (unsigned int i = 0; i < matrix_c.size(); ++i) {
		for (unsigned int j = 1; j <= matrix_b.size(); ++j) {
			simplex_matrix[i + 1][j + 1] = matrix_a[i][j - 1];
		}
	}
}

bool checking_s(double ** &simplex_matrix) {
	for (unsigned i = 1; i < matrix_b.size(); ++i) {
		if (simplex_matrix[i][1] < 0) {
			cout << "I found a -" << endl;
			return true;
		}
	}
	return false;
}

void first_stage(double ** simplex_matrix) {
	while (checking_s(simplex_matrix)) {
		cout << "start 1 stage" << endl;
		for (unsigned i = 1; i <= matrix_b.size(); ++i) {
			if (simplex_matrix[i][1] < 0) {
				for (unsigned j = 2; j <= matrix_c.size() + 1; ++j) {
					if (simplex_matrix[i][j] < 0) {
						cout << "start 1 stage Jordan" << endl;
						JordanExeptions(simplex_matrix, i, j);
						print(simplex_matrix);
						break;
					}
				}
			}
		}
	}
}

bool checking_F(double ** simplex_matrix) {
	for (unsigned i = 2; i <= matrix_c.size() + 1; ++i) {
		if (simplex_matrix[matrix_b.size()+1][i] > 0) {
			return true;
			break;
		}
	}
	return false;
}

void second_stage(double ** &simplex_matrix) {
	while (checking_F(simplex_matrix)) {
		cout << "start 2 stage" << endl;
		for (unsigned i = 2; i <= matrix_c.size() + 1; ++i) {
			if (simplex_matrix[matrix_b.size() + 1][i] > 0) {
				double min = 0;
				int min_j = 0;
				for (unsigned j = 1; j <= matrix_b.size(); ++j) {
					if (simplex_matrix[j][i] != 0 && simplex_matrix[j][1] / simplex_matrix[j][i] > 0) {
						min = simplex_matrix[j][1] / simplex_matrix[j][i];
						min_j = j;
						break;
					}
				}
				for (unsigned j = 1; j <= matrix_b.size(); ++j) {
					if (simplex_matrix[j][i] != 0 && simplex_matrix[j][1] / simplex_matrix[j][i] > 0 && simplex_matrix[j][1] / simplex_matrix[j][i] < min) {
						min = simplex_matrix[j][1] / simplex_matrix[j][i];
						min_j = j;
					}
				}
				cout << "start 2 stage Jordan" << endl;
				JordanExeptions(simplex_matrix, min_j, i);
				print(simplex_matrix);
			}
		}
	}
}

int main()
{
	//создаем матрицу
	double ** simplex_matrix;
	simplex_matrix = new double *[matrix_b.size() + 1];
	for (unsigned int i = 0; i <= matrix_b.size() + 1; ++i) {
		simplex_matrix[i] = new double[matrix_c.size() + 1];
	}
	create_simplex(simplex_matrix);
	print(simplex_matrix);
	first_stage(simplex_matrix);
	second_stage(simplex_matrix);
	//print(simplex_matrix);
	


	//удаление матрицы, так как мы выделяли память под нее
	for (unsigned int i = 0; i < matrix_b.size() + 1; ++i) {
		delete[] simplex_matrix[i];
	}
	delete[]simplex_matrix;
	std::cin.get();
}
